<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CityWalk·蜂巢剧场·《一个陌生女人的来信》</title>
    <url>/2023/03/03/CityWalk%C2%B7%E8%9C%82%E5%B7%A2%E5%89%A7%E5%9C%BA%C2%B7%E3%80%8A%E4%B8%80%E4%B8%AA%E9%99%8C%E7%94%9F%E5%A5%B3%E4%BA%BA%E7%9A%84%E6%9D%A5%E4%BF%A1%E3%80%8B/</url>
    <content><![CDATA[<img src="https://i.postimg.cc/mZ8bt69g/6fa3b7ddc9f14fd99517d44589fc428.jpg" style="zoom:150%;" />

<p>开学前两周完全被OO干烂心态所以忙里偷闲一小下（手动orz</p>
<p>二月居然只读了一本书，是杜拉斯的《情人》，好想看同名电影但是还没有找到时间</p>
<p>昨天在英语课上开始看伍尔夫的《达洛维夫人》。</p>
<img src="https://i.postimg.cc/7LDc1q88/37865bd71e3225e18f1c53efd3adfae.jpg" style="zoom:200%;" />

<img src="https://i.postimg.cc/fbw2t5mM/6740538956a4920fbea203375fc455d.jpg" style="zoom:200%;" />



<h2 id="先讲讲剧吧"><a href="#先讲讲剧吧" class="headerlink" title="先讲讲剧吧"></a>先讲讲剧吧</h2><p>《一个陌生女人的来信》<br>第一点是表演形式有非常震撼的地方（比如摇滚元素，吓得我前面的小哥哥一哆嗦）。用脱掉六条（还是七条）黑色内裤最后露出白色内裤表现女人挣扎的内心。还有做菜居然是真做，把肉放进热锅里会冒烟还有香味。女人弹吉他表示爱意真的非常动人。还有第二次和W先生在一起那天，用了手持camera的方式来表现玫瑰和女人的情欲，真的非常神奇，镜头里投影的画面和床单下滚动的人影，即使是独角剧也可以非常生动。<br>第二点是演技吧。黄湘丽一开始以写遗书的女人登场，但是当她讲起十三岁的故事，弹唱起十三岁的歌，整个人的声音变成了少女。真的是演什么像什么，不愧是独角剧女王。因为坐在靠后的位置，在手持camera那一段是我很少的能够看清演员表情的时候，不管是开心、希望还是痛苦都可以传达到观众的心里，真的好有灵气。而且她真的非常优雅、跑跑跳跳的动作都做得非常到位，不管是少女的轻快，追求爱情的焦躁，明知追求的爱并不明智的痛苦，对贫民窟的痛恨，都用肢体语言传达得非常到位。结束的时候工作人员说那些歌曲都是演员本人作词作曲，真的好厉害。<br>第一次看原著可能是在初中的时候，那个时候有种懵懵懂懂的震撼，并不懂其中的疯狂，但是下意识有种“哇 好厉害”的感觉，可能还是茨威格的笔力让我折服。这次看的时候全程在想一个问题<strong>“她为什么爱他？”</strong>，我感觉其中最重要的原因是自恋，疯狂地爱一个自己根本不了解的人其实本质是爱那个疯狂的奉献的自己吧，所以最后去爱孩子其实也可以解释为孩子是一个更符合自恋的对象。不过关于这个问题真的还想听听其他人的看法。</p>
<h2 id="遇见有趣的咖啡店是最有趣的事情！"><a href="#遇见有趣的咖啡店是最有趣的事情！" class="headerlink" title="遇见有趣的咖啡店是最有趣的事情！"></a>遇见有趣的咖啡店是最有趣的事情！</h2><img src="https://i.postimg.cc/pVnwtGBS/b4c3d9ef4bd410edebd116219f8df47.jpg" style="zoom:200%;" />
这家咖啡店还蛮有意思的，总之会送小杯咖啡让别人品尝味道就是很了不起的行为。不过除了了解豆子之外，我还很想知道这一杯是怎么做出来的，是手冲、半自动机萃取还是别的。（但是没问，倒不是社牛的问题，主要是不想打扰看起来还蛮忙的咖啡师，下次有机会还是去问！)]]></content>
      <categories>
        <category>CityWalk</category>
      </categories>
  </entry>
  <entry>
    <title>BUAA_Object-Oriented_Unit1</title>
    <url>/2023/03/16/BUAA_Object-Oriented_Unit1/</url>
    <content><![CDATA[<h2 id="hw1"><a href="#hw1" class="headerlink" title="hw1"></a>hw1</h2><h3 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h3><p><img src="https://i.postimg.cc/MKtbDgc7/Main-hw1.png" alt="Main_hw1"></p>
<h3 id="每个类的作用"><a href="#每个类的作用" class="headerlink" title="每个类的作用"></a>每个类的作用</h3><ul>
<li>Expr，有ArrayList&lt;Term&gt;，表示多个Term相加</li>
<li>Term，有ArrayList&lt;Factor&gt;表示多个Factor相乘</li>
<li>Factor，具有toPoly方法</li>
<li>Number，Factor的子类，表示带符号的数字</li>
<li>Var，Factor的子类，表示带幂次方的变量x或y或z</li>
<li>ExprFactor，Factor的子类，表示带幂次方的表达式</li>
<li>Poly多项式，具有ArrayList&lt;Mono&gt;以及若干加减和乘法的方法</li>
<li>Mono单项式，具有系数，x的次方数，y的次方数，z的次方数这些属性以及若干方法</li>
<li>Parser语法分析器，和Lexer一起使用从而把输入的String解析成一棵语法树</li>
<li>Lexer 词法分析器，通过next()方法来读取下一个curToken</li>
<li>Change对String类的字符串进行预处理</li>
</ul>
<h3 id="架构设计体验"><a href="#架构设计体验" class="headerlink" title="架构设计体验"></a>架构设计体验</h3><p>由于在上学期并没有学习先导课cpp，而是选择了swift，导致hw1布置下来的时候，我对递归下降以及java 的语法完全不清楚，除了Poly和Mono还有字符串处理类之外的类我都是模仿training1进行构建的。</p>
<p>由于training1进行的是将表达式转化为后缀，所以我在运算表达式这一步遇到了麻烦，不知道即使将expr的结构解析出来了，又将要如何去进行复杂的运算和化简，但是这一步从往届的博客中得到了启示。</p>
<p>我加入了<strong>Mono</strong>类和<strong>Poly</strong>类，Mono类含有表示x的指数的indexOfX，表示y的指数的indexOfY，表示z的指数的indexOfZ，以及系数Coe，还有一个toString方法（可以进行优化以简化表达式输出）。Poly即多项式，表示许多单项式的相加。由于Number和Var可以轻易地转化为多项式和单项式，Term转化为的多项式即是其元素ArrayList<Factor>中每个Factor转化为的多项式相乘，而Expr转化为的多项式即是其元素ArrayList<Term>中每个Factor转化为的多项式相加。</p>
<p>通过这个方法，我们把复杂的问题转化成了分割开来可以处理的小问题，降低了耦合度。单独为Mono设置单项式加减乘和为Poly设置多项式加减乘都不困难，而Expr层层调用toPoly也不困难，至于由String到Expr的解析过程则由Lexer和Parser完成。每个部分各司其职，让我初步体会到了面向对象封装、设置接口的思想的方便。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><blockquote>
<p><strong>OCavg</strong>是类平均圈复杂度</p>
<p><strong>OCmax</strong>是类最大圈复杂度</p>
<p><strong>WMC</strong>是类总圈复杂度</p>
</blockquote>
<p><img src="https://i.postimg.cc/x8p8kGCz/hw1.png" alt="hw1复杂度"></p>
<h2 id="hw2"><a href="#hw2" class="headerlink" title="hw2"></a>hw2</h2><h3 id="架构设计体验-1"><a href="#架构设计体验-1" class="headerlink" title="架构设计体验"></a>架构设计体验</h3><p>这次作业相比hw1增加的部分是自定义函数和三角函数，因此在Factor部分新加入了SinFactor,CosFactor,FuncFactor。新加入了Define类用来记录自定义函数的名字和形式参数，也定义了方法用于替换形参和实参。在Parse部分对形式符合自定义函数的部分进行了解析。</p>
<h3 id="分析bug"><a href="#分析bug" class="headerlink" title="分析bug"></a>分析bug</h3><p>第一次作业和第二次作业有一个共同的bug，就是没有注意到数字是可以带符号的，在我一开始测试的一些数据里，形如“+NumFactor”的情况中，会将“+NumFactor”视作一个Term，加号会被分析为Term的符号，因此不需要解析NumFactor的符号。但是在形如“sin（Factor）”的式子里面，不考虑符号就会出现runtimeError。这是一个很简单但是却很致命的bug。</p>
<p>改出bug后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigInteger num;</span><br><span class="line">            <span class="keyword">if</span> (lexer.peek().equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                lexer.next();</span><br><span class="line">                num = <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;-&quot;</span> + lexer.peek());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lexer.peek().equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                lexer.next();</span><br><span class="line">                num = <span class="keyword">new</span> <span class="title class_">BigInteger</span>(lexer.peek());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = <span class="keyword">new</span> <span class="title class_">BigInteger</span>(lexer.peek());<span class="comment">//Integer.parseInt(lexer.peek());</span></span><br><span class="line">            &#125;</span><br><span class="line">            lexer.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Number</span>(num);</span><br></pre></td></tr></table></figure>

<p>第二次作业还有一个bug是sin和cos括号里面的内容必须是Factor，但是ExprFactor解析出来的也可能不需要加括号，而Var幂函数解析出来的反而可能要加括号，因为没有注意到这个问题，在强测中我得到了很多format error。</p>
<p>更改的方法是增加对字符串的判断，如果不符合Factor的定义就加上一层括号使之成为ExprFactor去符合定义，这样才能放在必须是Factor的地方。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://i.postimg.cc/9FSzCBs3/hw2.jpg" alt="hw2复杂度"></p>
<h2 id="hw3"><a href="#hw3" class="headerlink" title="hw3"></a>hw3</h2><h3 id="架构设计体验-2"><a href="#架构设计体验-2" class="headerlink" title="架构设计体验"></a>架构设计体验</h3><p>相比第二次作业增加了求导因子</p>
<p>新增部分如下：</p>
<ul>
<li><p>求导因子类DeFactor</p>
<p>以下是这个类中比较重要的数据和方法</p>
<blockquote>
<p>Char ch</p>
<p>Expr expr</p>
<p><strong>Poly toPoly(){</strong></p>
<p>​    <strong>return expr.toDiffPoly（ch）</strong></p>
<p><strong>}</strong></p>
</blockquote>
</li>
<li><p>对Expr，Term和Factor（除了DeFactor）增加了toDiffPoly进行求导</p>
</li>
</ul>
<p>相比第二次作业还增加了可以在定义函数部分调用已经定义过的函数</p>
<p>因此新增的处理是在Define类读入定义的时候预先对表达式进行处理替换。</p>
<h3 id="bug分析"><a href="#bug分析" class="headerlink" title="bug分析"></a>bug分析</h3><p>这次作业在互测中被找出来了一个bug。</p>
<blockquote>
<p>在前几次作业中，exprFactor的幂次不能超过8。</p>
<p>在这次作业中，形如</p>
<blockquote>
<p>1</p>
<p>d(x) &#x3D; (（x）**2)**6</p>
<p>d(x)</p>
</blockquote>
<p>的数据中，由于我对d(x)定义中右边的式子在读入的时候进行了parser-toPoly-toString的处理以应对增加的“可以调用已经定义的函数”要求，所以实际上可能会遇到**(x)**12**这样的情况，原先在parseExprFactor时只读入一位幂次方的方法就会出错。</p>
</blockquote>
<p>这次bug让我体会到，一种改动可能会引起蝴蝶效应产生意想不到的bug，还是应该充分测试。另一方面，如果我从第一次作业就预先按照可能会有多位来处理parseExprFactor，这样的bug也就不会产生了。</p>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img src="https://i.postimg.cc/C55LVZNL/hw3.jpg" alt="hw3复杂度"></p>
<h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><p>  第一单元的OO作业对我来说是一个慢慢成长的过程，我看着代码风格分慢慢从不足50成长到最后一次作业的100，第一周一边学java语法一边学习面向对象知识直到ddl也完成不了任务没有通过公测，第二周在周五通过公测但是没有好好做测试没进互测，到第三周在周五通过公测并且在周日第一次进入互测。这个成长的过程是痛苦的，但是也有很多的成就感。除了对面向对象内容的学习，我还学会了很多自主学习的方法，在心态上也有非常多的成长。</p>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/10/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>计组记录</title>
    <url>/2022/12/31/%E8%AE%A1%E7%BB%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="计组记录"><a href="#计组记录" class="headerlink" title="计组记录"></a>计组记录</h1><h2 id="你会看到什么"><a href="#你会看到什么" class="headerlink" title="你会看到什么"></a>你会看到什么</h2><p>因为本人真的非常不擅长讲清楚一个知识点，所以这篇只是一个自我记录，不辜负辛辛苦苦学习计组的大半个学期，大概没有任何指导性作用。不过你还是可以通过本文了解北航的6系计组到底都让人干了点啥（）</p>
<p><img src="https://i.postimg.cc/2j2G5nzn/1f267c60f1776bc8022837cb5ff6a8a.png" alt="总览
"></p>
<h2 id="pre"><a href="#pre" class="headerlink" title="pre"></a>pre</h2><ol>
<li>logisim：简单的状态机</li>
<li>verilog：简单的状态机（因为当时不太清楚mealy型状态机输出会早于moore型状态机，所以面向波形编程了orz）</li>
<li>mips：求根（除了不能盲目列举之外没啥要注意的）</li>
</ol>
<p>过了的时候真的很开心，不过事实是，我还是菜鸡））））</p>
<h2 id="p0（logisim）"><a href="#p0（logisim）" class="headerlink" title="p0（logisim）"></a>p0（logisim）</h2><p>两道简单的状态机，一道斐波那契变形，最后一道题需要对logisim的时序部件比较熟悉</p>
<h2 id="p1（verilog状态机）"><a href="#p1（verilog状态机）" class="headerlink" title="p1（verilog状态机）"></a>p1（verilog状态机）</h2><p>难度和pre差不多</p>
<p>就是状态机</p>
<h2 id="p2（mips）"><a href="#p2（mips）" class="headerlink" title="p2（mips）"></a>p2（mips）</h2><p>首挂（泪目）</p>
<p>心态会有点崩溃的</p>
<p>反思出了几个问题：</p>
<ul>
<li><p>因为前三次都过了所以没有很重视计组，心态不太正确</p>
</li>
<li><p>没有弄清楚for，while，do-while三种循环的区别（for和while是一样的）</p>
<p>（本质其实是我c语言学得菜）</p>
</li>
<li><p>递归的“保护寄存器的值”的本质那时候还不太了解</p>
</li>
</ul>
<p>第二次解决了后两个问题，很顺利地写出了三道题</p>
<p>第三题是一道允许有括号的表达式计算（给了c语言代码）</p>
<h2 id="p3-（logisim-单周期）"><a href="#p3-（logisim-单周期）" class="headerlink" title="p3 （logisim 单周期）"></a>p3 （logisim 单周期）</h2><p>做课下的时候一次就过了三个测还很高兴</p>
<p>然后又被课上狠狠打击</p>
<p>反思出来的问题是：</p>
<ul>
<li><p>我其实不太了解logisim各个部件</p>
</li>
<li><p>没有通读指令集（lw，lb，lh以及sw，sh，sb都只是模模糊糊地会用，其实并不精确）</p>
<p>（这个问题在p6也背刺了我一下）</p>
</li>
</ul>
<p><img src="https://i.postimg.cc/CxqbbQ8p/425374dbaaa0b3e3203d136dbadbf84.png" alt="logisim部件
"></p>
<p>因为实在太心碎把自己关进了图书馆（本学期第一次去图书馆成就get）</p>
<h2 id="p4（verilog单周期）"><a href="#p4（verilog单周期）" class="headerlink" title="p4（verilog单周期）"></a>p4（verilog单周期）</h2><p>花了很长时间去了解verilog要怎么搭建电路</p>
<p>也花了很长时间debug</p>
<p>那个时候看觉得p4很难，花了一整个周末</p>
<p>从后来的眼光看，p4真的好简单</p>
<h2 id="p5（verilog多周期）"><a href="#p5（verilog多周期）" class="headerlink" title="p5（verilog多周期）"></a>p5（verilog多周期）</h2><p>从黑书上了解了多周期的基本原理</p>
<p>从大佬的博客<a href="https://thysrael.github.io/">qsgg的博客</a>上学会了AT法</p>
<p>（从黑书的做法改成AT法没花很长时间）</p>
<p>从这个时候获取知识的方法就变成了各路大佬的博客</p>
<p>“无脑阻塞”之类的知识对我来说也是口口相传得来的</p>
<p>不太了解大佬都是从哪里学会的</p>
<p>过得很神奇（问答我的助教说是那道题测试点太弱了</p>
<h2 id="p6（加了很多指令和乘除模块的verilog多周期）"><a href="#p6（加了很多指令和乘除模块的verilog多周期）" class="headerlink" title="p6（加了很多指令和乘除模块的verilog多周期）"></a>p6（加了很多指令和乘除模块的verilog多周期）</h2><p>做课下的时候不情不愿的，因为看起来工作量真的很大</p>
<p>但是结果倒是出奇地顺利</p>
<p>debug基本上只de了一个sb</p>
<p>过得依然很神奇，课上tle没过，但是助教复核的时候给过了</p>
<p>指令是<strong>shl：交换hi寄存器和lo寄存器的值</strong></p>
<p>更神奇的是上机上到四分之三被救护车拉去了方舱</p>
<p><em><del>新冠初体验</del></em></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实过了p6之后还有两周上机，如果愿意的话可以挑战p7和p8，但是我全gap了（复习了概统还有其他一学期没学过的东西）</p>
<p>没有挑战p7有一点点遗憾</p>
<p>想的就是：过了p6已经能拿一个我可以接受的分数了</p>
<p><em>希望能成为更加勇敢的人</em></p>
]]></content>
      <categories>
        <category>专业课</category>
      </categories>
  </entry>
  <entry>
    <title>Elizabeth(2005)</title>
    <url>/2023/06/12/Elizabeth-2005/</url>
    <content><![CDATA[<h1 id="“我只属于…我自己”"><a href="#“我只属于…我自己”" class="headerlink" title="“我只属于…我自己”"></a>“我只属于…我自己”</h1><p>  觉得还是该写一点感想。对这部剧的评价是非常“古典”，具有很强大的能打动人心的那种力量。</p>
<p>  故事讲述了Sisi挣扎的一生，从她对唯一懂她的父亲倾诉想要骑马奔跑、像吉普赛人那样自由生活开始展开。她并不是“叛逆”，只是格格不入，有的人生来就是black sheep，无法融入所在的群体，被束缚和捆绑，从而陷入痛苦。从楼上掉落，Sisi第一次遇见死神，生来孤独的她也和死神开始了独特的依恋与纠缠。</p>
<p>  和奥地利皇帝浪漫的相爱给了她昏头的爱情。她没有考虑之后的生活是否如意，就激动地投入了宫廷地怀抱。第一次相爱是这样的，被冲昏头脑，盲目幸福，以为得到了拯救和自由。直到被皇太后Sophie管教、失去女儿又失去和儿子见面的机会，Sisi才得到了当头一棒，逐渐清醒，不再天真、学会狠心，和皇帝谈判逐渐获得权力。</p>
<p>  在第一部分的结尾，Sisi自信地对死神宣告”我不再需要你，请你离开“。</p>
<p>  获得权利也是被权力绑架，斗争胜利带来的快乐也是一时的。从第二部分的开头，Sisi无法适应宫廷生活的束缚，发出了”宁愿穿上疯人院的束缚衣而不是宫廷的紧身衣”的呐喊。而当皇帝背叛了她之后，她更是发出了“你的背叛最终使我得到自由”的呼唤。</p>
<p>  压抑本性的痛苦让Sisi忽略了儿子的感受，太子Rudolf在孤独中也成为了死神的朋友。在皇帝背叛后，Sisi环游各国近二十年，肆无忌惮地追求自己的自由，对皇宫的害怕和自己的骄傲让她对儿子的求救视而不见，最终导致儿子的自杀，带给Sisi更大的痛苦。和死去的父亲对话，重复第一幕的童年对唱，带给观众时过境迁、经历一切折磨与斗争，而当初的痛苦和孤独仍然不变的悲凉之感。Sisi呼唤死神，而死神不愿回应。</p>
<p>  （和死神的”最后一舞“真的好好听啊）</p>
<p>  和皇帝最后的湖中相见也是令人感慨的一幕。皇帝在压抑的环境中长大、也适应压抑，他深爱Sisi，希望两人可以在最后达成相互的理解。而Sisi没有选择压抑和适应，奔向了最后的孤独。这是两种人生选择，而Franz Joseph的人生虽然比Sisi更妥协，但是在他的心境下，也许是更平静和幸福的一种人生。</p>
<p>  在这部剧中最看不懂的是关于政治的部分…….在奥匈帝国的时代，monarchy的权力究竟是多大，君主立宪到了什么地步，而为什么刺杀君主成为无政府主义者的行动。</p>
<p>关于演员：</p>
<p>Sisi的演员和安东尼娅家族的女主还是挺像的，属于那种坚毅、有力量感、能够表达痛苦的欧洲女人的脸。</p>
]]></content>
      <categories>
        <category>观剧</category>
      </categories>
  </entry>
  <entry>
    <title>os-lab6-challenge</title>
    <url>/2023/06/16/os-lab6-challenge/</url>
    <content><![CDATA[<h1 id="challenge-6"><a href="#challenge-6" class="headerlink" title="challenge-6"></a>challenge-6</h1><h2 id="梳理本challenge中重要的函数及实现的修改"><a href="#梳理本challenge中重要的函数及实现的修改" class="headerlink" title="梳理本challenge中重要的函数及实现的修改"></a>梳理本challenge中重要的函数及实现的修改</h2><p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/9e662441005e065ddbaa9c351818062.jpg" alt="9e662441005e065ddbaa9c351818062"></p>
<h2 id="必做部分-easy"><a href="#必做部分-easy" class="headerlink" title="必做部分-easy"></a>必做部分-easy</h2><h3 id="实现一行多命令"><a href="#实现一行多命令" class="headerlink" title="实现一行多命令"></a>实现一行多命令</h3><p>用 <code>;</code> 分开同一行内的两条命令，表示<strong>依次</strong>执行前后两条命令。<code>;</code> 左右的命令都可以为空。</p>
<p>提示：在 <code>user/sh.c</code> 中的保留 <code>SYMBOLS</code> 里已经预留有 <code>;</code> 字符。</p>
<p><strong>解决方法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sh.c parsecmd</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">		    *rightpipe = fork();</span><br><span class="line">			<span class="keyword">if</span> (*rightpipe == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> argc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 父进程</span></span><br><span class="line">				wait(*rightpipe);</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>左侧指令：子进程，直接返回参数</p>
<p>右侧指令：父进程，在子进程执行完毕之后继续解析</p>
<h3 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h3><p>用 <code>&amp;</code> 分开同一行内的两条命令，表示<strong>同时</strong>执行前后两条命令。<code>&amp;</code> 左侧的命令应被置于后台执行，<u>Shell 只等待 <code>&amp;</code> 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出</u>。你需要自行设计测试，以展现此功能的运行效果。<code>&amp;</code> 左侧的命令不能为空。</p>
<p>提示：在 <code>user/sh.c</code>中的保留 <code>SYMBOLS</code> 里已经预留有 <code>&amp;</code> 字符</p>
<p><strong>解决办法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 子进程</span></span><br><span class="line">				<span class="keyword">return</span> argc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>由于runcmd函数<strong>只等待child和rightpipe执行结束</strong>才能完成，所以不会等待左侧命令执行</p>
<h3 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h3><p>实现引号支持后，shell 可以处理如： <code>echo.b &quot;ls.b | cat.b&quot;</code> 这样的命令。即 shell 在解析时，会将双引号内的内容看作单个字符串，将 <code>ls.b | cat.b</code> 作为一个参数传递给 <code>echo.b</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/sh.c _gettoken</span></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*p1 = ++s;</span><br><span class="line">		<span class="keyword">while</span> (*s &amp;&amp; *s != <span class="string">&#x27;\&quot;&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s++;</span><br><span class="line">		&#125;</span><br><span class="line">		*p2 = s;</span><br><span class="line">		*s++ = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>修改<code>_gettoken</code>函数，在识别到引号的时候返回引号内的一整个字符串（即将p1修改为引号内字符串开始的位置，p2修改为引号内字符串结束的位置）</p>
<h3 id="实现程序名称中-b-的省略"><a href="#实现程序名称中-b-的省略" class="headerlink" title="实现程序名称中 .b 的省略"></a>实现程序名称中 <code>.b</code> 的省略</h3><p>目前的用户程序被烧录到文件系统中后，其可执行文件以 <code>.b</code> 为后缀，为 shell 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 <code>.b</code> 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 <code>.b</code> 再打开。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user/lib/spawn.c spawn</span></span><br><span class="line"><span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">char</span> temp[<span class="number">128</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(temp,prog);</span><br><span class="line">		<span class="type">int</span> len = <span class="built_in">strlen</span>(temp);</span><br><span class="line">        <span class="comment">//begin</span></span><br><span class="line">        temp[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">		temp[len+<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">		temp[len+<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>((fd = open(temp, O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> fd;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//end</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>尝试加入”.b”再次打开</p>
<p>如果再次打开仍然失败返回错误</p>
<h2 id="必做部分-hard"><a href="#必做部分-hard" class="headerlink" title="必做部分-hard"></a>必做部分-hard</h2><h3 id="实现键入命令时任意位置的修改"><a href="#实现键入命令时任意位置的修改" class="headerlink" title="实现键入命令时任意位置的修改"></a>实现键入命令时任意位置的修改</h3><p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p>
<p>上下左右</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UP: 	  \033[A</span></span><br><span class="line"><span class="comment">// DOWN:  \033[B</span></span><br><span class="line"><span class="comment">// Left:  \033[D</span></span><br><span class="line"><span class="comment">// Right: \033[C</span></span><br><span class="line"><span class="type">int</span> len;<span class="comment">//数组长度</span></span><br><span class="line"><span class="type">int</span> i;<span class="comment">//光标长度</span></span><br><span class="line"><span class="comment">//光标向左移动y个</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOVELEFT(y) printf(<span class="string">&quot;\033[%dD&quot;</span>, (y))</span></span><br><span class="line"><span class="comment">//光标向右移动y个</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOVERIGHT(y) printf(<span class="string">&quot;\033[%dC&quot;</span>,(y))</span></span><br></pre></td></tr></table></figure>

<p><strong>特判：</strong></p>
<ul>
<li><p>Backspace</p>
<ul>
<li><p>刷新输入框</p>
<ul>
<li>光标左移</li>
<li>printf</li>
<li>光标左移</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例 删除最后一个字符 刷新</span></span><br><span class="line">					buf[--i] = <span class="number">0</span>;</span><br><span class="line">					MOVELEFT(<span class="number">1</span>);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">					MOVELEFT(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>光标i之后的字符前移</p>
</li>
</ul>
</li>
<li><p>左右箭头</p>
<ul>
<li>光标变化</li>
<li>维持i与光标的关系</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp2 == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 左移</span></span><br><span class="line">					<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						i -= <span class="number">1</span>;</span><br><span class="line">						<span class="comment">//维持i的值与光标的位置一致</span></span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						MOVERIGHT(<span class="number">1</span>);</span><br><span class="line">						<span class="comment">//抵消</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="comment">//右移同理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上下箭头</p>
<ul>
<li>见history一节</li>
</ul>
</li>
</ul>
<h3 id="实现更丰富的命令"><a href="#实现更丰富的命令" class="headerlink" title="实现更丰富的命令"></a>实现更丰富的命令</h3><p>参考实验环境中的 Linux 命令 <code>tree</code>、<code>mkdir</code>、<code>touch</code> 来实现这三个命令，请尽可能地实现其完整的功能。</p>
<p>为了实现文件和目录的创建，你需要实现用户库函数 <code>mkdir()</code> 和文件打开模式 <code>O_CREAT</code>。</p>
<p>实现文件的创建后，你需要修改 shell 中输出重定向 <code>&gt;</code> 的实现，使其能够在目标路径不存在时自动创建并写入该文件。</p>
<h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p><strong>参考<code>ls.c</code>实现</strong></p>
<p><strong>注意</strong>：</p>
<ul>
<li>在tree命令最后要输出目录数量 + 文件数量</li>
<li>tree命令可以有不止一个参数，同时显示<strong>多个目录</strong>相关信息</li>
</ul>
<p><strong>相关函数：</strong></p>
<p>stat：粗略理解为打开文件，返回统计信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> st_name[MAXNAMELEN];</span><br><span class="line">	u_int st_size;</span><br><span class="line">	u_int st_isdir;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">st_dev</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//回顾lab5</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">    <span class="comment">//file descriptor</span></span><br><span class="line">    u_int fd_dev_id;</span><br><span class="line">    u_int fd_offset;<span class="comment">//表示文件里面指示位置的指针</span></span><br><span class="line">    u_int fd_omode;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">    u_int f_fileid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size;	 <span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;	 <span class="comment">// file type</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在linux系统下使用tree命令截取一段作为对照进行实现</span></span><br><span class="line">├── halt.c</span><br><span class="line">    ├── icode.b</span><br><span class="line">    ├── icode.b.c</span><br><span class="line">    ├── icode.c</span><br><span class="line">    ├── icode.x</span><br><span class="line">    ├── idle.c</span><br><span class="line">    ├── include</span><br><span class="line">    │   ├── fd.h</span><br><span class="line">    │   ├── fs.h</span><br><span class="line">    │   ├── fsreq.h</span><br><span class="line">    │   └── lib.h</span><br><span class="line"><span class="comment">//-f 模式</span></span><br><span class="line">    ├── ./user/include.mk</span><br><span class="line">    ├── ./user/init.b</span><br><span class="line">    ├── ./user/init.c</span><br><span class="line">    ├── ./user/lib</span><br><span class="line">    │   ├── ./user/lib/console.c</span><br><span class="line">    │   ├── ./user/lib/console.o</span><br><span class="line">    │   ├── ./user/lib/debugf.c</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//treedir</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f</span>;</span></span><br><span class="line">readn(fd, &amp;f, <span class="keyword">sizeof</span>(f))) == <span class="keyword">sizeof</span>(f));<span class="comment">//读取目录文件的子文件的struct File</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>判断是目录最后一个文件（需要输出<code>printf(&quot;└── &quot;);</code>而不是<code>printf(&quot;├── &quot;);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tree.c treedir</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">treedir</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> depth)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fdnum;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">//struct File f;</span></span><br><span class="line">    <span class="comment">//struct File pref;</span></span><br><span class="line">    <span class="comment">// open</span></span><br><span class="line">    <span class="keyword">if</span> ((fdnum = open(path, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;open %s: %d&quot;</span>, path, fdnum);</span><br><span class="line">    &#125;</span><br><span class="line">    fd = (<span class="keyword">struct</span> Fd *)num2fd(fdnum);</span><br><span class="line">    ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">    <span class="type">int</span> size = ffd-&gt;f_file.f_size;</span><br><span class="line">    <span class="type">int</span> va = (<span class="type">int</span>)fd2data(fd);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2FILE)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">file</span>;</span></span><br><span class="line">        file = (<span class="keyword">struct</span> File*)(va + i);</span><br><span class="line">        <span class="keyword">if</span>(file -&gt; f_name[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> islast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == size || (file + <span class="number">1</span>)-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            islast = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treefile(path, file-&gt;f_type == FTYPE_DIR, file-&gt;f_name, depth + <span class="number">1</span>,islast);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//treefile</span></span><br><span class="line"><span class="keyword">if</span>(islast)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;└── &quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;├── &quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对目录的蓝色显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-f需要输出完整命令</span></span><br><span class="line">    <span class="keyword">if</span> (flag[<span class="string">&#x27;f&#x27;</span>] &amp;&amp; path)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isdir)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m&quot;</span>, path);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m&quot;</span>, sep);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s%s&quot;</span>, path, sep);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isdir)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m\n&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><ul>
<li>main<ul>
<li>tree:打开文件<ul>
<li>treedir:对目录执行tree,对目录的子文件调用treefile<ul>
<li>treefile(如果判断为isdir会调用treedir</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="mkdir-amp-amp-touch"><a href="#mkdir-amp-amp-touch" class="headerlink" title="mkdir &amp;&amp; touch"></a>mkdir &amp;&amp; touch</h4><p>实现文件创建功能——实现<strong>调用链</strong>调用文件进程中的<code>file_create()</code></p>
<p><strong>参考已有调用实现</strong></p>
<ul>
<li>用户进程<ul>
<li><code>int fsipc_create(const char *, int);</code></li>
<li><code>int create(const char *path, int f_type);</code></li>
</ul>
</li>
<li>文件进程<ul>
<li><code>int file_create(char *path, struct File **file);</code></li>
</ul>
</li>
</ul>
<h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ul>
<li>在sh.c的main函数readline之后中增加<strong>保存指令</strong>功能</li>
<li>在readline函数中增加对\033[A和\033[B的特判</li>
</ul>
<p><strong>我的实现</strong></p>
<ul>
<li><p>保存历史指令 </p>
<p>原本：（后来仔细看指导书发现是禁止的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> history[<span class="number">1000</span>][<span class="number">128</span>];<span class="comment">//循环保存最近的1000条指令</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> k = <span class="number">0</span>;<span class="comment">//记录下一个指令在数组中的位置</span></span><br></pre></td></tr></table></figure>

<p>更改：（但是这个方法出现了一些bug）</p>
<ul>
<li><p>增加O_APPEND</p>
</li>
<li><p>新建&#x2F;.history文件保存历史指令</p>
<ul>
<li><p><code>static int init_history = 0</code>标志是否已经创建history文件</p>
</li>
<li><p><code>void savecmd(char * buf) </code>保存</p>
</li>
<li><p><code>int getcmd(int index, char *ans)</code>读取</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>readline上下键特判</p>
<ul>
<li><p>UP</p>
<ul>
<li><p>index &#x3D;&#x3D; k 保存当前已经输入的内容到<code>static char curcmd[1024];</code></p>
</li>
<li><p>index &gt; 0 </p>
<ul>
<li><p>抵消输入的UP <code>MOVEDOWN(1);</code></p>
</li>
<li><p>更改index <code>index--;</code></p>
</li>
<li><p>更改显示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOVELEFT(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">MOVELEFT(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,history[index]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改buf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">len = <span class="built_in">strlen</span>(history[index]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">	buf[j] = history[index][j];</span><br><span class="line">&#125;</span><br><span class="line">i = len;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>DOWN</p>
<ul>
<li>与UP类似</li>
<li>差别在：<ul>
<li>index &#x3D;&#x3D; k-1 用curcmd替换</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遇见的bug：主要还是逻辑错误，比如应该if-else的分支使用了if-if</p>
</blockquote>
</li>
<li><p>history指令：显示所有历史指令</p>
</li>
</ul>
<h2 id="选做：支持相对路径"><a href="#选做：支持相对路径" class="headerlink" title="选做：支持相对路径"></a>选做：支持相对路径</h2><ul>
<li><p>改变进程控制块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> r_path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加系统调用</p>
<ul>
<li>SYS_getRpath 获得相对路径</li>
<li>SYS_setRpath 改变相对路径</li>
</ul>
</li>
<li><p>pwd指令</p>
</li>
<li><p>拼装相对路径或绝对路径的逻辑，分为以下几类</p>
<ul>
<li>绝对路径</li>
<li>以..&#x2F;开头的相对路径</li>
<li>以.&#x2F;开头的相对路径</li>
<li>以文件名开头的相对路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cd</span></span><br><span class="line">		<span class="keyword">if</span>(buf[<span class="number">0</span>]==<span class="string">&#x27;c&#x27;</span> &amp;&amp; buf[<span class="number">1</span>] == <span class="string">&#x27;d&#x27;</span> &amp;&amp; buf[<span class="number">2</span>] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">			<span class="comment">//test</span></span><br><span class="line">			<span class="comment">//syscall_setRpath(&quot;/kern/test&quot;);</span></span><br><span class="line">			<span class="type">char</span> cur[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="type">char</span> dst[<span class="number">1024</span>];<span class="comment">//存储cd的参数</span></span><br><span class="line">			<span class="type">char</span> dir[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">			<span class="type">char</span> *pdst = dst;</span><br><span class="line">			<span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">			<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(buf[i] != <span class="number">0</span> &amp;&amp; buf[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; buf[i] != <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(buf[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">					i++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					dst[j++] = buf[i];</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			dst[j] = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//printf(&quot;%s\n&quot;,dst);</span></span><br><span class="line">			syscall_getRpath(cur);</span><br><span class="line">			<span class="type">int</span> lencur = <span class="built_in">strlen</span>(cur);</span><br><span class="line">			<span class="type">int</span> lendst = <span class="built_in">strlen</span>(dst);</span><br><span class="line">			<span class="keyword">if</span>(dst[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">				<span class="comment">//绝对路径</span></span><br><span class="line">				<span class="built_in">strcpy</span>(dir,dst);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(dst[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; dst[<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">				<span class="comment">//以../开头的相对路径</span></span><br><span class="line">				<span class="type">char</span> pre[<span class="number">1024</span>];</span><br><span class="line">                <span class="type">int</span> m;</span><br><span class="line">				<span class="type">int</span> len_m;</span><br><span class="line">				<span class="keyword">for</span>(m = lencur<span class="number">-1</span>;m &gt;=<span class="number">0</span>;m--)&#123;</span><br><span class="line">					<span class="keyword">if</span>(cur[m] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">					pre[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">					pre[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">					len_m = <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					len_m = m + <span class="number">1</span>;</span><br><span class="line">					pre[m+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">					pre[m] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">					m--;</span><br><span class="line">				    <span class="keyword">for</span>(;m&gt;=<span class="number">0</span>;m--)&#123;</span><br><span class="line">						pre[m] = cur[m];</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">strcpy</span>(pre + len_m,dst + <span class="number">3</span>);</span><br><span class="line">				<span class="built_in">strcpy</span>(dir,pre);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(dst[<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">				<span class="comment">//以./开头的相对路径</span></span><br><span class="line">				pdst += <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(cur,<span class="string">&quot;/&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(cur + lencur,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(cur + lencur + <span class="number">1</span>,pdst);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">strcpy</span>(cur + lencur,pdst);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">strcpy</span>(dir,cur);</span><br><span class="line">			&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//以文件名开头的相对路径</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">strcmp</span>(cur,<span class="string">&quot;/&quot;</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">strcpy</span>(cur + lencur,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">					<span class="built_in">strcpy</span>(cur + lencur + <span class="number">1</span>,dst);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">strcpy</span>(cur + lencur,dst);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">strcpy</span>(dir,cur);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,dir);</span><br><span class="line">			<span class="comment">//dir为拼好的绝对路径</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">			<span class="keyword">if</span>((r = stat(dir,&amp;st)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;bug1\n&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//bug:明明是dir却输出不是dir</span></span><br><span class="line">			<span class="comment">// if(!st-&gt;st_isdir)&#123;</span></span><br><span class="line">			<span class="comment">// 	printf(&quot;not a dir&quot;);</span></span><br><span class="line">			<span class="comment">// 	continue;</span></span><br><span class="line">			<span class="comment">// &#125; </span></span><br><span class="line">            <span class="keyword">if</span>(!st.st_isdir)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;not a dir&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; </span><br><span class="line">			chdir(dir);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bug:明明是dir却输出不是dir</p>
<p>”指针错误“</p>
</blockquote>
</li>
<li><p>除了cd部分需要拼装以支持相对路径的地方</p>
<ul>
<li><p>用户态的open函数</p>
<ul>
<li>在file.c里新建函数<code>void changePath(const char *dst, char *dir)</code>基本是上述代码逻辑</li>
</ul>
</li>
<li><p>ls(调用<code>void changePath(const char *dst, char *dir</code>)</p>
</li>
<li><p>tree(同上)</p>
</li>
<li><p>touch（改为在<strong>当前目录</strong>中创建）</p>
</li>
<li><p>mkdir（改为在<strong>当前目录</strong>中创建）</p>
</li>
<li><p>spawn</p>
<ul>
<li>防止把指令prog解释为相对路径</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spawn</span><span class="params">(<span class="type">char</span> *preprog, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Open the file &#x27;prog&#x27; (the path of the program).</span></span><br><span class="line">	<span class="comment">// Return the error if &#x27;open&#x27; fails.</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">    <span class="type">char</span> prog[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> *pprog = prog;</span><br><span class="line">	<span class="keyword">if</span>(preprog[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">		prog[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">		<span class="built_in">strcpy</span>(pprog + <span class="number">1</span>, preprog);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(prog,preprog);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#测试一行多命令</span><br><span class="line">touch testfile;mkdir dir</span><br><span class="line">#测试更丰富的命令</span><br><span class="line">tree</span><br><span class="line">#测试后台任务</span><br><span class="line">#测试引号支持</span><br><span class="line">#测试 .b省略</span><br><span class="line">echo world&amp;echo &quot;hello&quot;</span><br><span class="line">#接下来测试修改和回放命令</span><br><span class="line">#测试相对路径</span><br><span class="line">cd dir</span><br><span class="line">touch afile</span><br><span class="line">tree</span><br><span class="line">mkdir dir2 dir3</span><br><span class="line">cd dir2</span><br><span class="line">touch dir2file</span><br><span class="line">touch ../dir3/dir3file</span><br><span class="line">cd /</span><br><span class="line">tree -f</span><br></pre></td></tr></table></figure>

<p>最后的结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> tree -f</span><br><span class="line">/</span><br><span class="line">├── /testarg.b</span><br><span class="line">├── /cat.b</span><br><span class="line">├── /pingpong.b</span><br><span class="line">├── /testbss.b</span><br><span class="line">├── /newmotd</span><br><span class="line">├── /testpiperace.b</span><br><span class="line">├── /testpipe.b</span><br><span class="line">├── /motd</span><br><span class="line">├── /init.b</span><br><span class="line">├── /num.b</span><br><span class="line">├── /touch.b</span><br><span class="line">├── /mkdir.b</span><br><span class="line">├── /testfdsharing.b</span><br><span class="line">├── /ls.b</span><br><span class="line">├── /pwd.b</span><br><span class="line">├── /echo.b</span><br><span class="line">├── /sh.b</span><br><span class="line">├── /tree.b</span><br><span class="line">├── /halt.b</span><br><span class="line">├── /testptelibrary.b</span><br><span class="line">├── /testfile</span><br><span class="line">└── /dir</span><br><span class="line">   ├── /dir/afile</span><br><span class="line">   ├── /dir/dir2</span><br><span class="line">      └── /dir/dir2/dir2file</span><br><span class="line">   └── /dir/dir3</span><br><span class="line">      └── /dir/dir3/dir3file</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">24</span> files</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>专业课</category>
      </categories>
  </entry>
  <entry>
    <title>国王的演讲(2010)</title>
    <url>/2023/07/09/%E5%9B%BD%E7%8E%8B%E7%9A%84%E6%BC%94%E8%AE%B2(2010)/</url>
    <content><![CDATA[<p>  与其说是“历经无数困难终于完成战时演讲”，不如说是Bertie本人与被忽视甚至虐待的童年的和解，被陪伴在身边的妻子女儿以及偶然遇见的Lionel治愈的故事。</p>
<p>  他是一个国王的儿子，这理所当然让他身份高贵，哪怕是暴躁的脾气也被他人所接受。然而隐藏在背后的更多是一个害怕的男人，或者说孩子，一个面对必须接受的麦克风无法克服心中恐惧说出话的“poor man”（Lionel的儿子听见Duke of York演说时对父亲所说的话）。他仍然铭记第一个保姆对哥哥的喜爱和对自己的忽视，记得她在父母面前掐他，记得小时候哥哥以及别人嘲笑他的口吃，怀念十三岁早逝的弟弟，他喜欢拼航模，然而在宫廷里却不得不模仿父亲“喜欢”集邮。他也许在别人面前是高贵的，却不得不面对自己比所有人都“低下”的生理问题，不得不面对更为“高贵”的父亲对自己问题的斥责。</p>
<p>  我们当然可以说，他只不过有一些紧张和情感的动荡，他的生活比起同时代的大多数人实在是要幸运太多。但我们也可以从中获得的力量是，他是与我们站在一起的人，无论是谁站在什么位置都逃不过童年鬼魂般的追捕，创伤从梦中从身后从每一个脆弱的时候向我们袭来。那些被我们忽略或压抑的愤恨会以身体的形式表达出来。</p>
<p>  他是一个处在时代交接处的王子，面对君主制不断的衰弱，新思想的崛起，以及欧洲的动荡。他说自己只会当一个海军军官，却不得不被推上国王的位置。一个架空的国王，却承担无数人的期待，而这份期待又压在一张口吃的嘴上。</p>
<p>  只有面对充满支持的妻子，和两个可爱的女儿，他才可以放下在外人面前的那份警惕口吃维持尊严的紧张，眼神变得温柔放松，给两个女儿讲故事，也是他第一次在本片中展现出不那么口吃的样子。</p>
<p>  这部电影打动我的地方在于，它绝对不只是一个王公贵族战胜自己缺陷的故事，而是一个有创伤的人，一个会控制不住情绪常年抽烟的可怜人，拥有了美好的家庭、情感支撑，又在朋友的帮助下接纳自己、勇敢面对生活的故事。</p>
<p>  （每次看到Bertie抽烟就会想到最后乔治六世肺癌而死…….很唏嘘。从看到的关于他的影视作品和资料来看，他的童年未必是十分美好的，但是却给了自己的女儿伊丽莎白十分温柔的早年时光和最大的支持，大概他是最了解在这个年代需要支撑monarchy之痛的人了）</p>
]]></content>
      <categories>
        <category>观剧</category>
      </categories>
  </entry>
  <entry>
    <title>时间只有对我是洪流</title>
    <url>/2023/07/12/%E6%97%B6%E9%97%B4%E5%8F%AA%E6%9C%89%E5%AF%B9%E6%88%91%E6%98%AF%E6%B4%AA%E6%B5%81/</url>
    <content><![CDATA[<p>   昨晚和gwy打电话，我问她“你妹妹应该上初中了吧”，gwy说“她还是个小学生”。“可是我们上高中的时候她就是个小学生欸。”最后我弄清楚gwy的妹妹只是从三年级小学生变成了五年级的小学生。</p>
<p>  三年级到五年级好像没有任何变化，仍然是日复一日的上学下课走回家，因为作业写得不够好被妈妈戳着头斥责。可是这两年对我来说，生活像是被洪水冲走过许多回，又还给我一个又一个完全不一样的。让我思考我到底是谁。</p>
<p>  我好像一直在被环境同化。初中是一个特别竞争性、完全没有善意的环境，老师和学校都特别严苛，如果做得不够好就会受到身体惩罚，在那种环境中我每天都怀抱着恐惧的心理去拼命学习、希望在下一次考试中做得更好。有的老师会因为对某个同学突然不满意，就随手抄起地上一个书包向座位砸过去，见过这样的事情只会让我希望”下一个遭受到这种对待的人不要是我“。</p>
<p>  高中是一个完全不一样的环境，如果让我评价，我会觉得合一是一个很摆的可以躺平的好地方。高一的时候每天都在经历初中留下来的创伤，觉得很痛苦，完全不想学习，每天都懒洋洋的也不写作业。高二遇见了在那个时候几乎完全拯救了我的精神状态的人，放学去世纪金源买奶茶、去高速时代买奶茶、麦当劳还有肉脯，去家园买炸串、寿司和煎饼。能永远铭记的事情真的太多了，正是因为拥有”下着暴雨的晚自习下课和朋友偷偷跑去操场学习抽烟“，才让我感觉青春是如此的有趣。高三的时候在顶楼看过很多次云和夕阳，在连廊听过许多首乐队的歌，晚上回家玩棠棣之华玩到三四点，虽然很困，但是每天都很幸福。高三的寒假准备每天学习，后来一天也没学习，倒是做到了每天看一部电影，站在明珠那栋房子的窗前能看到楼下新东方，室内总是有许多小孩子在上课，整个高中没有补过课，真的很幸福。</p>
<p>  刚来北航的时候其实是个无法接受任何to do list的人，因为散漫惯了，被约束一点点都觉得很难受。大一的时候保持了散漫的习惯，数分期中没有及格，但是几乎是一点点也没有为此痛苦过。因为我根本不喜欢”成绩好“这个词，我根本不想要那样。</p>
<p>  但是是从什么时候开始，感受到了焦虑呢。因为社交焦虑想要改变自己内向的性格。因为不知道什么焦虑开始认真学习从学习获得的成就里得到快乐。其实我到现在也觉得<strong>这不是我</strong>。这不是我但是我却这样了。我最喜欢的，还是从图书馆借一本书找一个舒服的地方看一下午。我最喜欢的还是像小时候那样盘腿坐在地上看六七个小时的闲书。</p>
<p>  人真的很需要故友的原因，大概是在和故友的交流中，又能感受到自己。感受到自己真正想要的是什么，其实是什么样子的人。在大学收获到了很多，改掉了自己很多的毛病，但是也是时候，去找回让自己激动的自己了。</p>
<p>  当无数的任务和新的事情扑面而来，真的就像洪水席卷过来，而本能的反映就是划水——前进或者逃离，也许一不小心就忘记了太多的事情和自己的一些部分。如果带着觉知去看待，大概可以让时间变得慢一点、永恒一点。</p>
<p>  <em><strong>重新找到幸福的节奏吧。</strong></em></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
  <entry>
    <title>电影截图</title>
    <url>/2023/10/17/%E7%94%B5%E5%BD%B1%E6%88%AA%E5%9B%BE/</url>
    <content><![CDATA[<p>喜欢自己亲手截的图</p>
<p><strong>简爱</strong></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/76468c927f2f9ff60d1b67b606d1635.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/71b7a30954efe1435d96cd2bf199238.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/9b7d930ae9641f72523caa493feb1b1.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/0d024dc6c5c67ddcd6cf6708ac381ec.png"></p>
<p><strong>情人</strong></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/3dda7dd72c6356bdc55a2c60ad61781.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/1e40fdbdf507072633bc1c995b3b29e.png"></p>
<p><strong>夏日幽灵</strong></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/43d6322552834b03307a11427ac8870.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/b.png"></p>
<p><strong>过春天</strong></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/20e8dce59abb4067e479e635416438d.jpg"></p>
]]></content>
      <categories>
        <category>观剧</category>
      </categories>
  </entry>
  <entry>
    <title>穿普拉达的女王</title>
    <url>/2023/10/17/%E7%A9%BF%E6%99%AE%E6%8B%89%E8%BE%BE%E7%9A%84%E5%A5%B3%E7%8E%8B/</url>
    <content><![CDATA[<p>  最近的感受是，一些东西真的慢慢就没有那么重要了。穿得特别漂亮吸引别人的注意力，接长的睫毛，不但不健康、不舒适，而且并不是你。</p>
<p>  拍了很想拍的写真，化妆特别漂亮，但是和我差别好大。我其实很享受做平凡的我自己，我其实更愿意做一些我真正享受并且能感觉到成长的事情。</p>
<p>  可以和《购物狂的异想世界》做一个对比。《穿普拉达的女王》的女主Andrea是一个名牌大学的毕业生，想做严肃的记者却误入时尚杂志，在时尚中迷失而后意识到自己更喜欢原来的自己。《购物狂的异想世界》的女主是一个从小有心理缺失感，只有在购买时尚产品时才能有活着的thrill的时尚爱好者，没有办法进入时尚杂志，于是以财经杂志为跳板。在一系列（具有女主光环而又戏剧性）的事情中得到成长，意识到朋友和男主爱的是真正的自己，那才是真正重要的部分。她意识到她必须要放弃对时尚过度而不健康的迷恋，才可以赢回她起偏过的深爱的人的心，要展示一个改过的自己。</p>
<p>  相比之下很显然我觉得购物狂的异想世界更好看。不过另一方面，《穿普拉达的女王》对身处时尚世界并且乐在其中的女魔头们也做出了解读，这种生活也许不适合女主Andy，但是对于另一些人来说确是彻彻底底、与外界眼光无关的纯粹爱好。Miranda、Emily、Nigel与女主并不是同路人，但是他们之间仍然发展出了真诚的职场友情。《穿普拉达的女王》的优势在于它对职场生活的描述，而这在《购物狂的异想世界》中仅表现为女主莫名的才华、好运气以及罗曼史。</p>
<img src="https://raw.githubusercontent.com/3liana/MyPic/main/d166576801d74a7b1d8a5acc3deb34a.jpg" style="zoom:50%;" />
]]></content>
      <categories>
        <category>观剧</category>
      </categories>
  </entry>
  <entry>
    <title>邮差</title>
    <url>/2023/10/17/%E9%82%AE%E5%B7%AE/</url>
    <content><![CDATA[<p>  我想人类是渺小的生物。</p>
<p>  生物的本能是——生存。人碌碌无为、追求快乐，只要知道自己所做的事情有利于生存就可以达到“幸福”和“快乐”。</p>
<p>  人同时又是懂得一点“美”的生物。他有时也想做与生存无关的事情。</p>
<p>  美就像是麻醉剂，让人忘记生存。美给人的快乐和生存给人的快乐又完全不是一种东西。</p>
<p>  我想我是渺小的生物。但我在持续的错觉中把自己夸大，误以为我是圣洁的生物。对他人苛刻的背后是对自己更加苛刻。正是因为认识不到自己<br>“追求生存”的本质，要求自己成为高于世界的神，所以我不爱别人，不爱自己，不开心。</p>
<p>  要很多的生存，加上一点情趣。这就是持续稳定的幸福。</p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/0f11e4906e266347894f243a8dd9c2b.png"></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/48a0c1a84bad763d189a1820fe7dbe0.png"></p>
]]></content>
      <categories>
        <category>观剧</category>
      </categories>
  </entry>
  <entry>
    <title>很久没有坐在公园里看书了</title>
    <url>/2023/10/17/%E5%BE%88%E4%B9%85%E6%B2%A1%E6%9C%89%E5%9D%90%E5%9C%A8%E5%85%AC%E5%9B%AD%E9%87%8C%E7%9C%8B%E4%B9%A6%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/c.jpg"></p>
<p>  路过绿园的时候，突然发现我虽然很喜欢坐在凳子上看书听水声晒太阳，但是却几乎没有这么做过。近在咫尺却又无法触摸的梦想，这样想有点悲哀。为什么没有坐在公园里看书呢，因为我一般都背着大大的重重的装着游戏本的书包出门，移动起来很不方便，我只想找到一个可以待很久的地方放下书包，然后在不那么符合我心意的地方、在学习代码的间隙读书。</p>
<p>  虽然在公园读书不那么方便，但是意识到那种悲哀和可惜后，觉得可不可以下定决心，在周末的时候抽点时间，去做这件<strong>无用又无效率</strong>的事情，只是让自己开心呢。</p>
<p>  <em>去享受吧，不要犹豫。</em></p>
<p><img src="https://raw.githubusercontent.com/3liana/MyPic/main/c112174abbec3032ee51efd4e58aed8.jpg"></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
  </entry>
</search>
